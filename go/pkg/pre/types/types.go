package types

import (
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bn254"
)

// PreScheme defines the interface for a proxy re-encryption scheme
/*
This flow demonstrates how Party A can send an encrypted message to Party B through a proxy
using proxy re-encryption. This is useful when:
- A wants to delegate decryption rights to B
- Messages need to pass through an untrusted proxy
- Direct communication between A and B is not possible/desired
*/
// ------------------------
// This shows how Party A can send an encrypted message to Party B

// 1. Setup and Key Generation
// -------------------------
// // Initialize system
// pre := NewPreScheme()

// // Generate keys for A and B
// secretKeyA := types.SecretKey{...}  // A's secret key
// publicKeyA := pre.SecretToPubkey(secretKeyA)
// secretKeyB := types.SecretKey{...}  // B's secret key
// publicKeyB := pre.SecretToPubkey(secretKeyB)

// // A generates re-encryption key for proxy
// reEncryptionKey := pre.GenerateReEncryptionKey(
//     secretKeyA,    // A's secret key
//     publicKeyB,    // B's public key
// )
// // Send reEncryptionKey to proxy

// 2. A Encrypts Message (Second Level)
// --------------------------------
// // A encrypts the message using their own public key
// message := "Hello B, this is A!"
// scalar := generateRandomScalar()

// // Create second-level ciphertext
// secondLevelCiphertext := pre.SecondLevelEncryption(
//     publicKeyA,    // A's public key (important: not B's)
//     secretKeyB,    // Portion of B's secret key
//     message,
//     scalar,
// )
// // Send secondLevelCiphertext to proxy

// 3. Proxy Re-encrypts Message
// ---------------------------
// // Proxy receives:
// // - secondLevelCiphertext (from A)
// // - reEncryptionKey (generated by A)
// // - publicKeyB (B's public key)

// // Proxy performs re-encryption
// firstLevelCiphertext := pre.ReEncryption(
//     secondLevelCiphertext,
//     reEncryptionKey,
//     publicKeyB,
// )
// // Send firstLevelCiphertext to B

// 4. B Decrypts Re-encrypted Message
// --------------------------------
// // B receives firstLevelCiphertext from proxy
// decryptedMessage := pre.DecryptFirstLevel(
//     firstLevelCiphertext,
//     secretKeyB,
// )

// Important Security Properties in this Flow
// ------------------------------------
// 1. Proxy cannot read the message content
// 2. Proxy can only convert ciphertexts from A to B (unidirectional)
// 3. B receives a first-level ciphertext that looks like direct encryption
// 4. A's secret key remains secure even if proxy and B collude
// 5. Re-encryption key is specific to A->B relationship

// PreScheme defines the interface for a proxy re-encryption scheme
type PreScheme interface {
	// GenerateReEncryptionKey creates a re-encryption key for A->B transformation
	// Takes a portion of secret key from A and a portion of public key from B
	// Returns a point in the G2 group
	GenerateReEncryptionKey(secretA *SecretKey, publicB *PublicKey) *bn254.G2Affine

	// SecondLevelEncryption encrypts a message m under a public key
	// Returns the encrypted symmetric key and the encrypted message
	SecondLevelEncryption(secretA *SecretKey, message string, scalar *big.Int) (*SecondLevelSymmetricKey, []byte, error)

	// ReEncryption transforms a second-level ciphertext to a first-level one
	// Takes a second-level encrypted key and a re-encryption key
	// Returns a first-level encrypted key
	ReEncryption(encryptedKey *SecondLevelSymmetricKey, reKey *bn254.G2Affine) *FirstLevelSymmetricKey

	// SecretToPubkey derives a public key from a secret key
	SecretToPubkey(secret *SecretKey) *PublicKey

	// DecryptFirstLevel decrypts message using a first-level encrypted key
	// Takes an encrypted key, encrypted message, and a secret key
	// Returns the decrypted message as a string
	DecryptFirstLevel(encryptedKey *FirstLevelSymmetricKey, encryptedMessage []byte, secretKey *SecretKey) string

	// DecryptSecondLevel decrypts message using a second-level encrypted key
	// Takes an encrypted key, encrypted message, and a secret key
	// Returns the decrypted message as a string
	DecryptSecondLevel(encryptedKey *SecondLevelSymmetricKey, encryptedMessage []byte, secretKey *SecretKey) string
	IGet
}

type IGet interface {
	G1() *bn254.G1Affine
	G2() *bn254.G2Affine
	Z() *bn254.GT
}
