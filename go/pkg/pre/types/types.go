package types

import (
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bn254"
)

// PreScheme defines the interface for a proxy re-encryption scheme
/*
This flow demonstrates how Party A can send an encrypted message to Party B through a proxy
using proxy re-encryption. This is useful when:
- A wants to delegate decryption rights to B
- Messages need to pass through an untrusted proxy
- Direct communication between A and B is not possible/desired
*/
// ------------------------
// This shows how Party A can send an encrypted message to Party B

// 1. Setup and Key Generation
// -------------------------
// // Initialize system
// pre := NewPreScheme()

// // Generate keys for A and B
// secretKeyA := types.SecretKey{...}  // A's secret key
// publicKeyA := pre.SecretToPubkey(secretKeyA)
// secretKeyB := types.SecretKey{...}  // B's secret key
// publicKeyB := pre.SecretToPubkey(secretKeyB)

// // A generates re-encryption key for proxy
// reEncryptionKey := pre.GenerateReEncryptionKey(
//     secretKeyA,    // A's secret key
//     publicKeyB,    // B's public key
// )
// // Send reEncryptionKey to proxy

// 2. A Encrypts Message (Second Level)
// --------------------------------
// // A encrypts the message using their own public key
// message := "Hello B, this is A!"
// scalar := generateRandomScalar()

// // Create second-level ciphertext
// secondLevelCiphertext := pre.SecondLevelEncryption(
//     publicKeyA,    // A's public key (important: not B's)
//     secretKeyB,    // Portion of B's secret key
//     message,
//     scalar,
// )
// // Send secondLevelCiphertext to proxy

// 3. Proxy Re-encrypts Message
// ---------------------------
// // Proxy receives:
// // - secondLevelCiphertext (from A)
// // - reEncryptionKey (generated by A)
// // - publicKeyB (B's public key)

// // Proxy performs re-encryption
// firstLevelCiphertext := pre.ReEncryption(
//     secondLevelCiphertext,
//     reEncryptionKey,
//     publicKeyB,
// )
// // Send firstLevelCiphertext to B

// 4. B Decrypts Re-encrypted Message
// --------------------------------
// // B receives firstLevelCiphertext from proxy
// decryptedMessage := pre.DecryptFirstLevel(
//     firstLevelCiphertext,
//     secretKeyB,
// )

// Important Security Properties in this Flow
// ------------------------------------
// 1. Proxy cannot read the message content
// 2. Proxy can only convert ciphertexts from A to B (unidirectional)
// 3. B receives a first-level ciphertext that looks like direct encryption
// 4. A's secret key remains secure even if proxy and B collude
// 5. Re-encryption key is specific to A->B relationship
type PreScheme interface {
	// GenerateReEncryptionKey generates a re-encryption key for A->B relation
	// Takes the secret key of A and public key of B as input
	// Returns a point in G2 group representing the re-encryption key
	GenerateReEncryptionKey(secretA *big.Int, publicB *bn254.G2Affine) *bn254.G2Affine

	// SecondLevelEncryption performs the second level encryption
	// Encrypts a message under pkA such that it can be decrypted by A and delegatees
	// Takes public key of A, secret key portion of B, message, and a random scalar
	// Returns the second level ciphertext
	SecondLevelEncryption(pubkeyA *bn254.GT, secretB *big.Int, message string, scalar *big.Int) *SecondLevelCipherText

	// ReEncryption performs the re-encryption operation
	// Re-encrypts the ciphertext under the re-encryption key
	// Takes second-level ciphertext, re-encryption key, and public key of B
	// Returns the first-level ciphertext
	ReEncryption(ciphertext *SecondLevelCipherText, reKey *bn254.G2Affine, pubKeyB bn254.G2Affine) *FirstLevelCipherText

	// SecretToPubkey converts a secret key to its corresponding public key
	// Takes a secret key and returns the corresponding public key
	SecretToPubkey(secret *SecretKey) *PublicKey

	// DecryptFirstLevel decrypts a first-level ciphertext
	// Takes the ciphertext and secret key as input
	// Returns the decrypted message as a string
	DecryptFirstLevel(ciphertext *FirstLevelCipherText, secretKey *SecretKey) string
}
